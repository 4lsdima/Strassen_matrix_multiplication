/////////////////////////////***  Utilites ***//////////////////////////////////////////////////
#ifndef __MFUNCTIONS_HPP_INCLUDED__
#define __MFUNCTIONS_HPP_INCLUDED__

#include <random>
#include <algorithm> //std::sort()
#include <cassert>
#include <vector>
#include <string>
#include <iostream>
#include <cstdlib>

#include "matrix.hpp"

typedef std::size_t ty;


// Universal exceptional handler:
void handle_eptr(std::exception_ptr eptr) // passing by value is ok
{
    try
    {
        if(eptr) {std::rethrow_exception(eptr);}
    }
    catch(const std::exception& e)
    {
        std::cout << "Caught exception \"" << e.what() << "\"\n";
    }
}


double randomReal(double min, double max) //generates random double in [min, max)
{
	assert(min < max);
	std::random_device rd;  //Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
    	//Each call to dis(gen) generates a new random double
    std::uniform_real_distribution<> dis(min, max);//Use dis to transform the 
    // random unsigned int generated by gen into a double in [1, 2)
    return dis(gen);
} 
//   
matrix<double> makeRandMatrix(ty nr, ty nc, double min, double max)
{
	assert(nr>0 && nc>0);
	std::vector<double> v(nr*nc);
	for(auto& it:v)
	{
		it=randomReal(min,max);
	}
	return matrix<double>(nr,nc,v);
}
//
void remDublicates(std::vector<int>& v) //v must be sorted!
{
	if(v.size()==1){return;}
	std::vector<int>::iterator jt=v.begin();
	for (std::vector<int>::iterator  it= v.begin()+1; it!= v.end(); ++it)
	{
		if(*it!=*jt)
		{
			++jt;
			if(it!=jt)
			{
				*jt=*it;
			}
		}
	}
	v.resize(jt-v.begin()+1);
}

matrix<short> permutMatrix (const std::vector<int>& P) // makes a permuntation matrix corresponding to permutations inside  vector<int>
{
 	std::vector<int> P1(P);
  	std::sort(P1.begin(), P1.end());
  	remDublicates(P1);
  	assert(P1.size()==P.size());
	matrix<short>M(P.size(),P.size());
  	
  	for (ty i = 0; i < P.size(); ++i)
	{
 		if (P[i]!=P1[i])
 		{
 			for(ty j=0;j<P.size();++j)
 			{
 				if(P[j]==P1[i])
 				{
 					M(i,j)=1;
 				}
 			}
 		}
 		else{M(i,i)=1;}	
 	}
 	return M;
}

template <class T>
void matrix2File(const matrix<T>& Matrix, const std::string& fName) // saves matrix's content to text file
{
	std::ofstream myfile(fName);
	if(myfile.is_open())
	{
		myfile<< Matrix.r << std::endl;
		myfile<< Matrix.c << std::endl;
		std::vector<T> v(Matrix.getVec());
		for(auto& it : v)
		{
			myfile<< it << std::endl;
		}
		myfile.close();
	}
}

matrix<double> file2Matrix(const std::string& fName) // reads a text file of numbers to make matrix<double> 
{
	ty nr(0);
	ty nc(0);
	std::vector<double> v;

	std::ifstream in((const char *)fName.c_str());
  	if(!in) { 	std::cerr << "Cannot open input file.\n"; 	}
  	else 
  	{
		int co(0); 
		ty len(0); 
		ty l(0);		
  		std::stringstream ss;
  		ss << in.rdbuf();    
  		for (std::string line; getline(ss, line); )
  		{
  			if(co==0)
  			{
  				nr=std::stoi(line);
  				++co;
  			}
  			else if(co==1)
  			{
  				nc=std::stoi(line);
  				++co;
  				len=nr*nc;
  			}
  			else
  			{
  				if(l<len)
  				{
  					v.push_back(std::stod(line));
  					++l;
  				}
  			}
        }
  	}
  	in.close();
  	return matrix<double>(nr,nc,v);
}


// just for printing out any vectors... :
template<class T>
void showVec(const std::vector<T>& v)
{
	std::cout<<" ^\n";
	for (auto& it:v)
	{
		std::cout<<it<<"\n";
	}
	
	std::cout<<" #\n";
	std::cout<<"\n";
	std::cout<<"  size = "<<v.size()<<std::endl;
}


#endif